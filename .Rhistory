if(TRUE) {
print("I got here")
}
if(FALSE){
print("I can't get here")
}
x = 10
if(x > 2) {
print("X is larger than 2")
} else { # notice that these are on the same line
print("X is 2 or smaller")
}
x = 3
if(x > 2) {
print("X is larger than 2")
} else { # notice that these are on the same line
print("X is 2 or smaller")
}
x = -3
if(x > 2){
print("X is larger than 2")
} else { # notice that these are on the same line
print("X is 2 or smaller")
}
x = c(0, 2)
ifelse(x > 1, "yes", "no") # but you can only put in values in here, not a bunch of instructions.
yes = c("yes1", "yes2")
no = c("no1", "no2")
ifelse(x > 1, yes, no)
yes = c("yes1", "yes2")
no = c("no1", "no2")
ifelse(x > 1, yes, no)
x
x = 3
if (x > 2) y = 2 * x else y = 3 * x
y
plot(NULL, xlim=c(0, 100), ylim=c(0, 1)) # make a blank plot with the limits set by those vectors
x = 1
repeat {
y = 1 / x
x = x + 1
points(x, y)
if (x == 100) {
break
}
}
Fib1 = 1
Fib2 = 1
Fibonacci = c(0, Fib2)
repeat {
Fibonacci = c(Fibonacci, Fib2)
oldFib2 = Fib2
Fib2 = Fib1 + Fib2
Fib1 = oldFib2
if (Fib2 > 300) {
break
}
}
Fibonacci
plot(NULL, xlim=c(0, 100), ylim=c(0, 1))
x = 0
while(x < 100) {
y = 1 / x
x = x + 1
points(x, y)
}
Fib1 = 1
Fib2 = 1
Fibonacci = c(0, Fib2)
while(Fib2 <= 300) {
Fibonacci = c(Fibonacci, Fib2)
oldFib2 = Fib2
Fib2 = Fib1 + Fib2
Fib1 = oldFib2
}
Fibonacci
for (monkey in c("Spider", "Howler", "Jacob")) {
## Each loop does the equivalent of: monkey = "Spider" or monkey = "Howler"
print(monkey)
}
for (i in 1:20){
print(i)
}
plot(NULL, xlim=c(0, 100), ylim=c(0, 1))
for (i in 0:100) {
points(i, 1 / i)
}
some.odds = NULL
for (i in 1:200) {
if (i %% 2 == 0) {
next
}
some.odds = c(some.odds, i)
}
some.odds
ev.third=NULL
ev.third=NULL
for (i in 3:100){
if (i %% 3 != 0 ){
next
}
ev.third=c(ev.third,i)
}
ev.third
for (i in 1:20){
1:i
}
1:20
for (i in 1:20){
1:i
}
for (i in 1:20){
print(1:i)
}
for (i in 20){
print(1:i)
}
20:1
c(1:20,19:1)
for (i in c(1:20,19:1){
print(1:i)
}
for (i in c(1:20,19:1){
c(1:20,19:1)
for (i in 1:c(1:20,19:1){
print(1:i)
}
for (i in c(1:20,19:1)){
print(1:i)
}
?sample
sample(c("H","T"))
sample(c("H","T"),size=1)
sample(c("H","T"),size=1)
sample(c("H","T"),size=1)
sample(c("H","T"),size=1)
sample(c("H","T"),size=1)
sample(c("H","T"),size=1)
sample(c("H","T"),size=1)
sample(c("H","T"),size=1)
sample(c("H","T"),size=1)
sample(c("H","T"),size=1)
sample(c("H","T"),size=1)
library(sfsmisc)
library(cubature)
library(pracma)
library(lattice)
install.packages("sfsmisc")
install.packages("cubature")
install.packages("pracma")
library(sfsmisc)
library(cubature)
library(pracma)
mixDist <- function(x){
(.8*dnorm(x, mean=1, sd=1)+.2*dnorm(x, mean=-1, sd=.4))
}
curve(from=-3, to=4, mixDist, n=1000)
ans <- .8*(pnorm(2, mean=1, sd=1)-pnorm(-2, mean=1, sd=1))+
.2*(pnorm(2, mean=-1, sd=.4)-pnorm(-2, mean=-1, sd=.4))
ans
segments(-2, 0, -2, mixDist(-2), lwd=2)
segments(2, 0, 2, mixDist(2), lwd=2)
cord.x <- c(-2,seq(-2,2,0.01),2)
cord.y <- c(0,mixDist(seq(-2,2,0.01)),0)
polygon(cord.x,cord.y,col='skyblue')
n <- 101
x <- seq(-2, 2, len = n)
y <- mixDist(x)
trapz(x, y)
ans
trapz(x, y)-ans
n <- 1010
x <- seq(-2, 2, len = n)
y <- mixDist(x)
trapz(x, y)
trapz(x, y)-ans
(integrate(mixDist, -2, 2)
integrate(mixDist, -2, 2)$value -ans
(integrate(mixDist, -2, 2)
)
### Fixed Gauss-Hermite quadrature
points <- seq(from=-2, to=2, length=40)
integrate.xy(points, mixDist(points))
integrate.xy(points, mixDist(points))-ans
mcInt <- function(ftn, a, b, n){
u <- runif(n, a, b)
x <- sapply(u, ftn)
return(mean(x)*(b-a))
}
mcInt(mixDist, -2, 2, 10000)
mcInt(mixDist, -2, 2, 10000)-ans
mcInt(mixDist, -2, 2, 100000)
mcInt(mixDist, -2, 2, 100000)-ans
dimensions=2
ndraws=1000
vals <- matrix(rnorm(2*1000), ncol=dimensions, nrow=ndraws)
dim(vals)
library(mvtnorm)
install.packages("mvtnorm")
library(mvtnorm)
probs <- dmvnorm(vals, mean=rep(0, dimensions), sigma=diag(rep(1, dimensions)))
probs
total <- data.frame(cbind(probs, vals))
colnames(total) <- (c("probs", "V1", "V2"))
cloud(probs~V1*V2, data=total)
?cloub
?cloud
myNorm <- function(x){
dmvnorm(x, mean=rep(0, dimensions), sigma=diag(rep(1, dimensions)))
}
ans <- pmvnorm(upper=rep(.5, dimensions), mean=rep(0, dimensions), sigma=diag(rep(1, dimensions)))
ans <- as.numeric(ans)
ans
adaptIntegrate(myNorm, lowerLimit=rep(-100, dimensions), upperLimit=rep(.5, dimensions))
adaptIntegrate(myNorm, lowerLimit=rep(-100, dimensions), upperLimit=rep(.5, dimensions))$integral -ans
mcInt <- function(ftn, a, b, n, dimensions){
u <- runif(n*dimensions, a, b)
these <- matrix(u, ncol=dimensions)
x <- apply(these,1, ftn)
return(mean(x)*(b-a)^dimensions)
}
mcInt(myNorm, -4, .5, n=100000, dimensions=2)-ans
dimensions=c(5,15,25)
ndraws=1000
rnorm(2*1000)
vals <- matrix(rnorm(dimensions[1]*1000), ncol=dimensions[1], nrow=ndraws)
dim(vals)
vals <- matrix(rnorm(dimensions[1]*1000), ncol=dimensions[1], nrow=ndraws)
probs <- dmvnorm(vals, mean=rep(0, dimensions[1]), sigma=diag(rep(1, dimensions[1])))
probs
adaptIntegrate(myNorm, lowerLimit=rep(-100, dimensions), upperLimit=rep(.5, dimensions))
mcInt(myNorm, -4, .5, n=100000, dimensions=15)-ans
mcInt(myNorm, -4, .5, n=100000, dimensions=5)
myNorm
dmvnorm(x, mean=rep(0, dimensions[1]), sigma=diag(rep(1, dimensions[1])))
myNorm <- function(x){
dmvnorm(x, mean=rep(0, dimensions[1]), sigma=diag(rep(1, dimensions[1])))
}
adaptIntegrate(myNorm, lowerLimit=rep(-100, dimensions[1]), upperLimit=rep(.5, dimensions[1]))
mvrnorm
?mvrnorm
library(MASS)
?mvrnorm
?logit
?ilogit
?logit
?ilogit
library(MASS)
?ilogit
library(faraway)
?ilogit
install.packages("Rcpp")
library(Rcpp)
library(Rcpp)
library()
library(Rcpp)
install.packages("Rcpp")
library(Rcpp)
cppFunction('int add(int x, int y, int z) {
int sum = x + y + z;
return sum;
}')
add
add(1,2,3)
add(2.1, 2.4, 5.2)
add(2.9, 2.4, 5.2)
add(c(2.1, 2.2), c(1.9, 1.8), c(5, 5))
addR<-function(x, y, z){
return(x+y+z)
}
addR
addR(1,2,3)
addR(2.1, 2.4, 5.2)
addR(c(2.1, 2.2), c(1.9, 1.8), c(5, 5))
library(microbenchmark)
microbenchmark(add(1,2,6), times=10000, unit="ns")
microbenchmark(addR(1,2,6), times=10000)
microbenchmark(add(1,2,6),addR(1,2,6))
stupidSum<-function(x){
output<-NULL
for(i in 1:length(x)){
output<-output+x[i]
}
return(output)
}
stupidSum(runif(10000000))
stupidSum<-function(x){
output<-NULL
for(i in 1:length(x)){
output<-output+x[i]
}
return(output)
}
runif(10000)
stupidSum<-function(x){
output<-0
for(i in 1:length(x)){
output<-output+x[i]
}
return(output)
}
stupidSum(runif(10000))
cppFunction('double stupidSumCpp(NumericVector x) {
int n = x.size();
double total=0;
for(int i=0; i<n; ++i) {
total += x[i];
}
return total;
}')
microbenchmark(stupidSum(runif(1000)), times=10000, unit="ns")
microbenchmark(stupidSumCpp(runif(1000)), times=10000)
setwd("C:/Users/ststest/Dropbox/Spr16/Programming/RCPP")
setwd("C:/Users/ststest/Dropbox/Spr16/Programming/Rcpp")
setwd("C:/Users/ststest/Dropbox/Spr16/Programming/RCCP")
sourceCpp("Example1.cpp")
dnorm(2, 1, 1)*.75 + dnorm(2, 0, 1)*.25
dnorm(2, 1, 1)
dnorm(2, 0, 1)
dnorm(2, 1, 1)*.75 + dnorm(2, 0, 1)*.25
?dnorm
double thisEval=R::dnorm(x[i], means[j], sd, FALSE);
## We are trying to calculate this number
dnorm(2, 1, 1)*.75 + dnorm(2, 0, 1)*.25
dnorm(1, 1, 1)*.75 + dnorm(1, 0, 1)*.25
weightedNormals(c(2,1), c(1,0), c(.75, .25), sd=1)
?weightedNormals
sourceCpp("Example2.cpp")
install.packages("BaM")
library(BaM)
BaM
?afghan.deaths
data(afghan.deaths)
afghan.deaths
install.packages("EBMAforecast")
library(EBMAforecast)
data("presidentialForecast")
View(presidentialForecast)
1/6
setwd("C:/Users/ststest/Dropbox/Spr16/Programming/BAMnew") #This will need to be changed to match your directory
create("BaM")
library(devtools)
library(roxygen2)
create("BaM")
library(BaM)
?bcp
current.code <- as.package("integrateIt")
current.code <- as.package("BaM")
load_all(current.code)
?china.wars
current.code <- as.package("BaM")
load_all(current.code)
document(current.code)
current.code <- as.package("BaM")
load_all(current.code)
document(current.code)
load("C:/Users/ststest/Dropbox/Spr16/Programming/BAMold/BaM/data/._actuarial.rda")
load("C:/Users/ststest/Dropbox/Spr16/Programming/BAMold/BaM/data/actuarial.rda")
actuarial
library(BaM)
?biv.norm.post
?bcp
create("BaM2")
current.code <- as.package("BaM2")
load_all(current.code)
document(current.code)
library(BaM)
install.packages("BaM")
install.packages("BaM")
library(BaM)
?biv.norm.post
data.n10 <- rmultinorm(10, c(1,3), matrix(c(1.0,0.7,0.7,3.0),2,2))
current.code <- as.package("BaM2")
library(devtools)
library(roxygen2)
current.code <- as.package("BaM2")
load_all(current.code)
document(current.code)
?biv.norm.post
load("C:/Users/ststest/Dropbox/Spr16/Programming/BAMold/BaM/data/DA_cwp.rda")
DA_cwp
current.code <- as.package("BaM2")
load_all(current.code)
document(current.code)
